{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/location-bar/location-bar.js","src/js/app.js","src/js/exports.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjVA,IAAI,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC;;AAErB,IAAI,WAAW,GAAG,OAAO,CAAC,cAAc,CAAC,CAAC;AAC1C;;AAEA,GAAG,GAAG;EACJ,IAAI,EAAE,YAAY;IAChB,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;IACzB,IAAI,CAAC,eAAe,EAAE,CAAC;IACvB,IAAI,CAAC,OAAO,EAAE,CAAC;IACf,IAAI,CAAC,gBAAgB,EAAE,CAAC;AAC5B,GAAG;;EAED,gBAAgB,EAAE,YAAY;AAChC,IAAI,IAAI,WAAW,GAAG,IAAI,WAAW,EAAE,CAAC;AACxC;;AAEA,IAAI,WAAW,CAAC,QAAQ,CAAC,UAAU,IAAI,EAAE;;MAEnC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;AAC5B,KAAK,CAAC,CAAC;;IAEH,WAAW,CAAC,KAAK,CAAC;MAChB,SAAS,EAAE,KAAK;KACjB,CAAC,CAAC;AACP,GAAG;;EAED,OAAO,EAAE,YAAY;IACnB,IAAI,IAAI,GAAG,IAAI,CAAC;IAChB,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE;AAC9B,MAAM,CAAC,CAAC,cAAc,EAAE,CAAC;;AAEzB,MAAM,IAAI,IAAI,GAAG,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;;MAEvC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;MACvB,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;KACvC,CAAC,CAAC;AACP,GAAG;;EAED,eAAe,EAAE,YAAY;IAC3B,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,CAAC;IAC/D,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;AACjD,GAAG;;EAED,WAAW,EAAE,UAAU,KAAK,EAAE;IAC5B,MAAM,CAAC,QAAQ,CAAC,IAAI,GAAG,KAAK,CAAC;AACjC,GAAG;;EAED,WAAW,EAAE,UAAU,IAAI,EAAE;IAC3B,IAAI,IAAI,CAAC,cAAc,KAAK,IAAI,EAAE,CAAC,OAAO,KAAK,CAAC,CAAC;IACjD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;IAC3B,IAAI,SAAS,GAAG,CAAC,CAAC,sBAAsB,CAAC;AAC7C,MAAM,IAAI,GAAG,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC;;AAEhD,IAAI,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACzB;;IAEI,IAAI,CAAC,YAAY,EAAE,CAAC;AACxB,GAAG;;EAED,iBAAiB,EAAE,UAAU,IAAI,EAAE;AACrC,IAAI,IAAI,WAAW,GAAG,CAAC,CAAC,gBAAgB,CAAC,CAAC;;IAEtC,WAAW,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;IACpC,CAAC,CAAC,SAAS,GAAG,IAAI,GAAG,IAAI,CAAC,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;AACpD,GAAG;;EAED,YAAY,EAAE,YAAY;IACxB,IAAI,CAAC,OAAO,EAAE,CAAC;AACnB,GAAG;;EAED,OAAO,EAAE,YAAY;GACpB,CAAC,CAAC,YAAY,CAAC,CAAC,SAAS,CAAC,YAAY,EAAE,SAAS,KAAK,EAAE;KACtD,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI;OACV,KAAK,CAAC,QAAQ,CAAC,eAAe,CAAC;MAChC,CAAC;IACH,CAAC,CAAC;AACN,GAAG;;AAEH,CAAC,CAAC;;AAEF,CAAC,EAAE,CAAC,KAAK,CAAC,YAAY;EACpB,GAAG,CAAC,IAAI,EAAE,CAAC;CACZ,CAAC,CAAC;;;ACnFH,IAAI,GAAG,GAAG,MAAM,CAAC,GAAG,IAAI,EAAE,CAAC;;AAE3B,MAAM,CAAC,GAAG,GAAG,GAAG,CAAC","file":"app.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","// LocationBar module extracted from Backbone.js 1.1.0\n//\n// the dependency on backbone, underscore and jquery have been removed to turn\n// this into a small standalone library for handling browser's history API\n// cross browser and with a fallback to hashchange events or polling.\n\n(function(define) {\ndefine(function() {\n\n  // 3 helper functions we use to avoid pulling in entire _ and $\n  var _ = {};\n  _.extend = function extend(obj, source) {\n    for (var prop in source) {\n      obj[prop] = source[prop];\n    }\n    return obj;\n  }\n  _.any = function any(arr, fn) {\n    for (var i = 0, l = arr.length; i < l; i++) {\n      if (fn(arr[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n  \n  function on(obj, type, fn) {\n    if (obj.attachEvent) {\n      obj['e'+type+fn] = fn;\n      obj[type+fn] = function(){ obj['e'+type+fn]( window.event ); };\n      obj.attachEvent( 'on'+type, obj[type+fn] );\n    } else {\n      obj.addEventListener( type, fn, false );\n    }\n  }\n  function off(obj, type, fn) {\n    if (obj.detachEvent) {\n      obj.detachEvent('on'+type, obj[type+fn]);\n      obj[type+fn] = null;\n    } else {\n      obj.removeEventListener(type, fn, false);\n    }\n  }\n\n\n\n\n\n  // this is mostly original code with minor modifications\n  // to avoid dependency on 3rd party libraries\n  //\n  // Backbone.History\n  // ----------------\n\n  // Handles cross-browser history management, based on either\n  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or\n  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\n  // and URL fragments. If the browser supports neither (old IE, natch),\n  // falls back to polling.\n  var History = function() {\n    this.handlers = [];\n\n    // MODIFICATION OF ORIGINAL BACKBONE.HISTORY\n    //\n    // _.bindAll(this, 'checkUrl');\n    //\n    var self = this;\n    var checkUrl = this.checkUrl;\n    this.checkUrl = function () {\n      checkUrl.apply(self, arguments);\n    };\n\n    // Ensure that `History` can be used outside of the browser.\n    if (typeof window !== 'undefined') {\n      this.location = window.location;\n      this.history = window.history;\n    }\n  };\n\n  // Cached regex for stripping a leading hash/slash and trailing space.\n  var routeStripper = /^[#\\/]|\\s+$/g;\n\n  // Cached regex for stripping leading and trailing slashes.\n  var rootStripper = /^\\/+|\\/+$/g;\n\n  // Cached regex for detecting MSIE.\n  var isExplorer = /msie [\\w.]+/;\n\n  // Cached regex for removing a trailing slash.\n  var trailingSlash = /\\/$/;\n\n  // Cached regex for stripping urls of hash.\n  var pathStripper = /#.*$/;\n\n  // Has the history handling already been started?\n  History.started = false;\n\n  // Set up all inheritable **Backbone.History** properties and methods.\n  _.extend(History.prototype, {\n\n    // The default interval to poll for hash changes, if necessary, is\n    // twenty times a second.\n    interval: 50,\n\n    // Are we at the app root?\n    atRoot: function() {\n      return this.location.pathname.replace(/[^\\/]$/, '$&/') === this.root;\n    },\n\n    // Gets the true hash value. Cannot use location.hash directly due to bug\n    // in Firefox where location.hash will always be decoded.\n    getHash: function(window) {\n      var match = (window || this).location.href.match(/#(.*)$/);\n      return match ? match[1] : '';\n    },\n\n    // Get the cross-browser normalized URL fragment, either from the URL,\n    // the hash, or the override.\n    getFragment: function(fragment, forcePushState) {\n      if (fragment == null) {\n        if (this._hasPushState || !this._wantsHashChange || forcePushState) {\n          fragment = decodeURI(this.location.pathname + this.location.search);\n          var root = this.root.replace(trailingSlash, '');\n          if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);\n        } else {\n          fragment = this.getHash();\n        }\n      }\n      return fragment.replace(routeStripper, '');\n    },\n\n    // Start the hash change handling, returning `true` if the current URL matches\n    // an existing route, and `false` otherwise.\n    start: function(options) {\n      if (History.started) throw new Error(\"LocationBar has already been started\");\n      History.started = true;\n\n      // Figure out the initial configuration. Do we need an iframe?\n      // Is pushState desired ... is it available?\n      this.options          = _.extend({root: '/'}, options);\n      this.location         = this.options.location || this.location;\n      this.history          = this.options.history || this.history;\n      this.root             = this.options.root;\n      this._wantsHashChange = this.options.hashChange !== false;\n      this._wantsPushState  = !!this.options.pushState;\n      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);\n      var fragment          = this.getFragment();\n      var docMode           = document.documentMode;\n      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));\n\n      // Normalize root to always include a leading and trailing slash.\n      this.root = ('/' + this.root + '/').replace(rootStripper, '/');\n\n      if (oldIE && this._wantsHashChange) {\n        // MODIFICATION OF ORIGINAL BACKBONE.HISTORY\n        //\n        // var frame = Backbone.$('<iframe src=\"javascript:0\" tabindex=\"-1\">');\n        // this.iframe = frame.hide().appendTo('body')[0].contentWindow;\n        //\n        this.iframe = document.createElement(\"iframe\");\n        this.iframe.setAttribute(\"src\", \"javascript:0\");\n        this.iframe.setAttribute(\"tabindex\", -1);\n        this.iframe.style.display = \"none\";\n        document.body.appendChild(this.iframe);\n        this.iframe = this.iframe.contentWindow;\n        this.navigate(fragment);\n      }\n\n      // Depending on whether we're using pushState or hashes, and whether\n      // 'onhashchange' is supported, determine how we check the URL state.\n      if (this._hasPushState) {\n        on(window, 'popstate', this.checkUrl);\n      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {\n        on(window, 'hashchange', this.checkUrl);\n      } else if (this._wantsHashChange) {\n        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n      }\n\n      // Determine if we need to change the base url, for a pushState link\n      // opened by a non-pushState browser.\n      this.fragment = fragment;\n      var loc = this.location;\n\n      // Transition from hashChange to pushState or vice versa if both are\n      // requested.\n      if (this._wantsHashChange && this._wantsPushState) {\n\n        // If we've started off with a route from a `pushState`-enabled\n        // browser, but we're currently in a browser that doesn't support it...\n        if (!this._hasPushState && !this.atRoot()) {\n          this.fragment = this.getFragment(null, true);\n          this.location.replace(this.root + '#' + this.fragment);\n          // Return immediately as browser will do redirect to new url\n          return true;\n\n        // Or if we've started out with a hash-based route, but we're currently\n        // in a browser where it could be `pushState`-based instead...\n        } else if (this._hasPushState && this.atRoot() && loc.hash) {\n          this.fragment = this.getHash().replace(routeStripper, '');\n          this.history.replaceState({}, document.title, this.root + this.fragment);\n        }\n\n      }\n\n      if (!this.options.silent) return this.loadUrl();\n    },\n\n    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\n    // but possibly useful for unit testing Routers.\n    stop: function() {\n      off(window, 'popstate', this.checkUrl);\n      off(window, 'hashchange', this.checkUrl);\n      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);\n      History.started = false;\n    },\n\n    // Add a route to be tested when the fragment changes. Routes added later\n    // may override previous routes.\n    route: function(route, callback) {\n      this.handlers.unshift({route: route, callback: callback});\n    },\n\n    // Checks the current URL to see if it has changed, and if it has,\n    // calls `loadUrl`, normalizing across the hidden iframe.\n    checkUrl: function() {\n      var current = this.getFragment();\n      if (current === this.fragment && this.iframe) {\n        current = this.getFragment(this.getHash(this.iframe));\n      }\n      if (current === this.fragment) return false;\n      if (this.iframe) this.navigate(current);\n      this.loadUrl();\n    },\n\n    // Attempt to load the current URL fragment. If a route succeeds with a\n    // match, returns `true`. If no defined routes matches the fragment,\n    // returns `false`.\n    loadUrl: function(fragment) {\n      fragment = this.fragment = this.getFragment(fragment);\n      return _.any(this.handlers, function(handler) {\n        if (handler.route.test(fragment)) {\n          handler.callback(fragment);\n          return true;\n        }\n      });\n    },\n\n    // Save a fragment into the hash history, or replace the URL state if the\n    // 'replace' option is passed. You are responsible for properly URL-encoding\n    // the fragment in advance.\n    //\n    // The options object can contain `trigger: true` if you wish to have the\n    // route callback be fired (not usually desirable), or `replace: true`, if\n    // you wish to modify the current URL without adding an entry to the history.\n    navigate: function(fragment, options) {\n      if (!History.started) return false;\n      if (!options || options === true) options = {trigger: !!options};\n\n      var url = this.root + (fragment = this.getFragment(fragment || ''));\n\n      // Strip the hash for matching.\n      fragment = fragment.replace(pathStripper, '');\n\n      if (this.fragment === fragment) return;\n      this.fragment = fragment;\n\n      // Don't include a trailing slash on the root.\n      if (fragment === '' && url !== '/') url = url.slice(0, -1);\n\n      // If pushState is available, we use it to set the fragment as a real URL.\n      if (this._hasPushState) {\n        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\n\n      // If hash changes haven't been explicitly disabled, update the hash\n      // fragment to store history.\n      } else if (this._wantsHashChange) {\n        this._updateHash(this.location, fragment, options.replace);\n        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {\n          // Opening and closing the iframe tricks IE7 and earlier to push a\n          // history entry on hash-tag change.  When replace is true, we don't\n          // want this.\n          if(!options.replace) this.iframe.document.open().close();\n          this._updateHash(this.iframe.location, fragment, options.replace);\n        }\n\n      // If you've told us that you explicitly don't want fallback hashchange-\n      // based history, then `navigate` becomes a page refresh.\n      } else {\n        return this.location.assign(url);\n      }\n      if (options.trigger) return this.loadUrl(fragment);\n    },\n\n    // Update the hash location, either replacing the current entry, or adding\n    // a new one to the browser history.\n    _updateHash: function(location, fragment, replace) {\n      if (replace) {\n        var href = location.href.replace(/(javascript:|#).*$/, '');\n        location.replace(href + '#' + fragment);\n      } else {\n        // Some browsers require that `hash` contains a leading #.\n        location.hash = '#' + fragment;\n      }\n    }\n\n  });\n\n\n\n  // add some features to History\n\n  // a more intuitive alias for navigate\n  History.prototype.update = function () {\n    this.navigate.apply(this, arguments);\n  };\n\n  // a generic callback for any changes\n  History.prototype.onChange = function (callback) {\n    this.route(/^(.*?)$/, callback);\n  };\n\n  // checks if the browser has pushstate support\n  History.prototype.hasPushState = function () {\n    if (!History.started) {\n      throw new Error(\"only available after LocationBar.start()\");\n    }\n    return this._hasPushState;\n  };\n\n\n\n\n\n\n  // export\n  return History;\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });","var App = window.App;\n\nvar LocationBar = require(\"location-bar\");\n\n\nApp = {\n  init: function () {\n    this.currentPattern = '';\n    this.getCurrentRoute();\n    this.bindNav();\n    this.initializeRouter();\n  },\n\n  initializeRouter: function () {\n    var locationBar = new LocationBar();\n\n    // listen to all changes to the location bar\n    locationBar.onChange(function (path) {\n      // console.log(\"the current url is\", path);\n      App.getPatterns(path);\n    });\n\n    locationBar.start({\n      pushState: false\n    });\n  },\n\n  bindNav: function () {\n    var self = this;\n    $('a').click(function (e) {\n      e.preventDefault();\n\n      var file = e.target.hash.split('#')[1];\n\n      self.updateRoute(file);\n      self.updateSelectedNav(e.target.hash);\n    });\n  },\n\n  getCurrentRoute: function () {\n    this.getPatterns(window.location.hash.split('#')[1] || 'home');\n    this.updateSelectedNav(window.location.hash);\n  },\n\n  updateRoute: function (route) {\n    window.location.hash = route;\n  },\n\n  getPatterns: function (file) {\n    if (this.currentPattern === file) {return false;}\n    this.currentPattern = file;\n    var container = $('[data-content-block]'),\n      tmpl = window.App.templatizer[\"_\" + file];\n\n    container.html(tmpl);\n\n    // Fire JS that has to wait to load\n    this.fireCustomJS();\n  },\n\n  updateSelectedNav: function (hash) {\n    var navListLink = $('.nav-list li a');\n\n    navListLink.removeClass('selected');\n    $('[href=\"' + hash + '\"]').addClass('selected');\n  },\n\n  fireCustomJS: function () {\n    this.counter();\n  },\n\n  counter: function () {\n   $('.countdown').countdown(\"2016/10/07\", function(event) {\n     $(this).text(\n       event.strftime('%D days to go')\n     );\n   });\n  }\n\n};\n\n$().ready(function () {\n  App.init();\n});\n","var App = window.App || {};\n\nwindow.App = App;\n"]}